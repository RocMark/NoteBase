# 重要觀念

# Revealing Pattern
```js
  function Book(title) {
    console.log('This will Run')
    this.title = title
    this.private = 'Cant Get!'
    this.public = 'Can Get!'
    this.getSummary = function () { return `${this.title}` }
    return {
      title,
      public: this.public,
      getSummary: this.getSummary,
    }
  }
  const b1 = new Book('Book One')
  console.log(b1.public) // Can Get !
  console.log(b1.private) // undefined
```

# ES6 Class (搜 JS OOP Crash)
```js
  class Book {
    constructor(title, author, year) {
      this.title = title
      this.author = author
      this.year = year
      this.objFunc = function () {
        console.log('所有建立的物件 都會含有此Func')
      }
    }
    // 方法應寫於 constructor 外
    // 此等同於 ES5 在 Book的原型上 建 getSummary
    // Book.prototype.getSummary() ~
    getSummary() {
      return `${this.title} written by ${this.author} in ${this.year}`
    }

    // ESLint 會建議除了 static 外的 Function 應該都會用到 this 關鍵字
    sayHey() { console.log('Hey') }
    // 可以不需要使用 new 建立物件即可使用的 Function
    static sayHi() { console.log('Hi') }
  }
  const b1 = new Book()
  Book.sayHi() // 會執行 Hi，需要用原型上執行
  // b1.sayHi() // is not a Function
  // Book.sayHey() // is not a Function

  class Magazine extends Book {
    // super 用法
    constructor(title, author, year, month) {
      super(title, author, year)
      this.month = month
    }
  }
  const mag = new Magazine('Mag One', 'Mark', 2015, 'March')
  console.log(mag.getSummary())
```

* 有字串參與加減，即為字串

# 運算子優先順序 [上至下，同層左至右]
濃縮版:  
.()[] 欄位存取、陣列索引、函式呼叫
=> 一元運算(++,-,!,typeof,new)
=> 乘除餘後加減 
=> 大小等於   => 雙/三等號比較 
=> 邏輯運算&& => 指派值=> 逗號