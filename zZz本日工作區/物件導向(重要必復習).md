# 物件導向 29:15始
> https://www.youtube.com/watch?v=HNjS4gxvy48
//? 封裝程式碼，隱藏底層實作免干擾。

人A 給 人B 一個蘋果
蘋果往右100px (X)
人A.給(B,蘋果)   (O)


# 範例程式碼  //! 重要必看復習
```js
    // LV1 分開、不好管理
    let personName = 'Frank'
    let personSpeak = function (name) {
        console.log(`Hello ${name}`)
    }

    // LV2 使用物件，傳入person確保他有需要的屬性
    let person2 = {
        name: 'Frank',
        gender: 'Male',
    }
    let personSpeak2 = function (who) {
        console.log(`Hello ${who.name}`)
    }

    // LV3 建立新的person 重寫部分太多
    let person3 = {
        name: 'Frank',
        speak() {
            console.log(`Hello ${this.name}`)
        },
    }

    // LV4 建立成Function 可 prototype繼承
    //* 類別定義通常會大寫
    let Person = function (name, gender) {
        this.name = name
        this.gender = gender
        this.speak = function () {
            console.log(`Hello I'm ${this.name} I'm ${this.gender}`)
        }
    }
    let frank = new Person('Frank', 'Male')
    // 僅修改 frank 的 speak
    frank.speak = function () {
        console.log('Hello')
    }
    let tom = new Person('Tom', 'Male')
    frank.speak()
    tom.speak()


    //? LV5 使用 prototype 繼承 將常用函數凝結在一起
    //! 物件只放屬性，方法放於prototype

    let Person2 = function (name, gender) {
        this.name = name
        this.gender = gender
    }
    //? 此 speak方法會位於原型
    Person2.prototype.speak = function () {
        console.log(`Hello I'm ${this.name} I'm ${this.gender}`)
    }
    let frank2 = new Person2('Frank', 'Male')
    let tom2 = new Person2('Tom', 'Male')
    frank2.speak()
    tom2.speak()
```

# 覆蓋函數/屬性
會從底層往上找，最下層會先執行
```js
    WorkPerson.prototype.speak = function(){
        console.log('Aloha')
    }
```

# 繼承
1. 使屬性可用 .call() 呼叫建構函數(產生器)
2. 連接函數 Object.create(Person.prototype)
創造空物件，其prototype為 Person，所以可用Person函數
WorkPerson 的 Prototype 為該空物件，可於該物件定義 WorkPerson的方法
```js
    let WorkPerson = function (name, gender, work) {
        //? 讓 WorkPerson 可以使用 Person的函數
        Person.call(this, name, gender)
        this.work = work
    }

    //? 使 WorkPerson 可用 Person函數，但不可更動 Person函數

    //* 產生新的空物件，繼承於Person，WorkPerson函數寫入此，即不會影響 Person擁有的函數(Person無法使用 speakWork)
    WorkPerson.prototype = Object.create(Person.prototype)

    // 勿用，因為如此Person也可以使用 speakWork!
    // WorkPerson.prototype = Person.prototype

    WorkPerson.prototype.speakWork = function () {
        console.log(`My work is ${this.work}`)
    }

    let workperson3 = new WorkPerson('Mark', 'male', 'teacher')
    //* (O) Person屬性 套用成功
    console.log(workperson3.name)

    //! (X)  WorkPerson沒定義 speak，未套用函數連結
    workperson3.speak()
```