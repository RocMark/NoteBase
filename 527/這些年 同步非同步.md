# 這些年經歷過的同步非同步

# jQuery Defer
jQuery Defer 等同於 後來的 Promise

* $.ajax / $.getJSON
都已經包好非同步了 [jQ 3.x版 支援到 IE9]

* $.Deferred() 為一個物件
可由 console.dir($.Deferred()) 查看

* resolve 通過
* reject 錯誤
```js
  return new Promise((resolve, reject) => {
    resolve('OK')
    // reject(new Error('Error'))
  })
  //* 等同於
  $.Deferred().promise()
  // 此方法會回傳，因此可達到鏈式的效果
  return defer.promise( obj );

  .then() / .catch() / 
```
## jQuery Defer 範例碼
//* d2 做完 然後做 d3 然後做 callBack Function
```js
  function d2() {
    const def = $.Deferred()
    setTimeout(() => {
      console.log(2)
      def.resolve('OK')
    }, 1000)
    return def.promise()
  }

  function d3() {
    const def = $.Deferred()
    setTimeout(() => {
      console.log(3)
      def.resolve('d3 Func OK')
      // def.reject('d3 Func ERR')
    }, 1000)
    return def.promise()
  }

  function mix() {
    console.log(1)
    d2().then(d3).then((msg) => {
      // resolve
      console.log(`${msg}`)
      console.log(4)
      console.log(5)
    })
      .catch((err) => {
      // reject
        console.log(`ERR ${err}`)
      })
  }
  mix()
```

# ES6 Promise 物件
* 需要用 new Promise 去產生實體物件
reject / resolve
```js
  function task() {
    return new Promise((resolve, reject) => {
      //! 在此中撰寫 AJAX / setTimeout 
      //* 正確時回傳 resolve 反之 reject
      resolve('OK')
      // reject(new Error('Error'))
    })
  }

  let p1 = new Promise((resolve, reject) => {
    resolve('OK')
    // reject(new Error('Error'))
  })
  
  // task().then 回傳 task2()
  // ? 丟出 task2().then() 類似 jQuery 鏈式

  //? 可所有流程共用 catch error

  task().then((result) => {
    console.log(result)
    return task2()
  }).then((result) => {
    console.log(result)
    return task3()
  }).catch((err) => {
    console.log(err)
  })
```

* promise-all
一次送出去，等到所有回來才會做 then()
無法控制順序，控制性較少，小專案才會用(方便)
```js
  Promise.all([task1(), task2()])
    .then((result) => {
      console.log(result)
    }).catch((err) => {
      console.log(err)
    })
```
* promise-race (非常少用)
通常會看整個過程，不會只看首個回傳

# Generator [基本用不到]

# async / await
基於 promise 的 語法糖
await 的用意，取代/省略 then & catch
* async
```js
  (async function () {
    //* 先執行 a 再 執行 b 再執行 c

    //* 此 run Function 為非同步 Function 
    //* 所以要等待 run 跑完才會放入 a變數中
    const a = await run()
    const b = await run()
    const c = await run()
  }())
```

* await Error
// ? JS中 如果有一個 Error 沒有做 try catch 就會中斷
通常會寫於將 try catch 寫於 function 內較乾淨

//! 如果
task2() 需要用到 task1() 的資料，
需要前先用 if 判斷 task1() 回傳的資料!
```js
  async function run2() {
    try {
      throw new Error()
    } catch (e) {
      console.log(e)
    } finally {
      console.log('finally')
    }
    return 'ok'
  }
```

# try catch finally
finally 不管正確、錯誤都會執行
//! 不應該於 finally 放 return
//* finally 的 return 會覆蓋 try 的 return

try catch 越精簡越好、效能較 if 較差
//? 因為 run time 才會做 compile
```js
  async function run() {
    let result = true
    try {
      return result
    } catch (e) {
      console.log(e)
      result = false
      return result
    } finally {
      console.log('不放return 必會執行')
    }
  }
```