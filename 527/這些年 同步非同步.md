# 這些年經歷過的同步非同步

# jQuery Defer
jQuery Defer 等同於 後來的 Promise
* $.ajax / $.getJSON
都已經包好非同步了 [jQ 3.x版 支援到 IE9]
* $.Deferred() 為一個物件
可由 console.dir($.Deferred()) 查看

* resolve 通過
* reject 錯誤
```js
  return new Promise((resolve, reject) => {
    resolve('OK')
    // reject(new Error('Error'))
  })
  //* 等同於
  $.Deferred().promise()
  // 此方法會回傳，因此可達到鏈式的效果
  return defer.promise( obj );

  .then() / .catch() / 
```
## jQuery Defer 範例碼
//* d2 做完 然後做 d3 然後做 callBack Function
```js
  function d2() {
    const def = $.Deferred()
    setTimeout(() => {
      console.log(2)
      def.resolve('OK')
    }, 1000)
    return def.promise()
  }

  function d3() {
    const def = $.Deferred()
    setTimeout(() => {
      console.log(3)
      def.resolve('d3 Func OK')
      // def.reject('d3 Func ERR')
    }, 1000)
    return def.promise()
  }

  function mix() {
    console.log(1)
    d2().then(d3).then((msg) => {
      // resolve
      console.log(`${msg}`)
      console.log(4)
      console.log(5)
    })
      .catch((err) => {
        // reject
        console.log(`ERR ${err}`)
      })
  }
  mix()
```

# ES6 Promise 物件
* 需要用 new Promise 去產生實體物件
reject / resolve [正確時回傳 resolve 反之 reject]

## 基本創建 Promise
```js
  let p1 = new Promise((resolve, reject) => {
    resolve('OK')
  })
  let 21 = new Promise((resolve, reject) => {
    reject(new Error('Error'))
  })

  p1.then((result) => {
    console.log(result)
  })

  p2.then((result) => {
    console.log(result)
  }).catch((err) => {
    console.log(err)
  })
```

* 可共用 catch error 但不佳。
所有流程其一出錯 error　訊息，相同難以　debug
* task().then 回傳 task2() [類jQuery 鏈式]
```js
  function task() {
    return new Promise((resolve, reject) => {
      //! 在此中撰寫 AJAX / setTimeout 
      resolve('OK')
      // reject(new Error('Error'))
    })
  }
  task().then((result) => {
    console.log(result)
    return task2()
  }).then((result) => {
    console.log(result)
    return task3()
  }).catch((err) => {
    console.log(err)
  })
```
# async / await ESLint
> https://goo.gl/EXuUv7
* 安裝 babel-eslint
* eslintrc 加入
"parser": "babel-eslint"


# async / await
基於 promise 的 語法糖
async 可以省略自行撰寫 promise
async / await 的好處: 可以快速的了解順序性 
(一行做完換下一行...)
* async
```js
  async function run() {
    return 'Hey run'
  }

  function test() {
    return new Promise((resolve) => {
      resolve('Hey test')
    })
  }
```
//! await 方法一定要寫在 async 裡面
# await 
用意於取代掉 then & catch [可以省略不寫]
1. run() 代表非同步 Function
2. await 代表需要等待 該 非同步 Function 執行完畢
3. 等完成功後，寫入a 變數中。
4. 完成await 進入下一塊 try catch
5. 因為非同步 Function 不保證一定會正確， [參下方try]
因此需要 Error Handle 避免 JS 無法繼續執行。

* 通常會寫於將 try catch 寫於 function 內較乾淨
```js
  // a,b,c 的值 要等待 run 執行完才放入該變數
  async function run() { return 'Hey run' }
  async function failed() { throw new Error() }
  (async () => {
    const a = await run() // 完成之後才做try catch
    try {
      const b = await failed()
    } catch (e) {
      console.log(e) // await failed 發生錯誤進入此
    }
    // 此行因為沒用 try catch 失敗，會導至 JS無法繼續執行
    const c = await failed() 
  })()
```

## try catch 意義
* async / await 錯誤處理
try catch 意義: 
1. 試著先做(try)
2. 出事就進入catch，沒事就寫入變數
//? JS為單線程程式，只要有一個錯誤就會無法繼續執行，
因此需要用 try catch 將 Error 接起來避免中斷。

## 將 try catch 包入 Function
* 通常會寫於將 try catch 寫於 function 內較乾淨
```js
  // 兩種寫法皆可
  async function run2() {
    let result = true
    try {
      // resolve
    } catch (e) {
      // reject
      result = false
      console.log(e)
    }
    return result
  }

  async function run1() {
    try {
      // AJAX過成錯誤進入 catch
      return 'ok'
    } catch (e) {
      throw e
      // console.log(e)
      return 'fail'
    }
  }
```

## try catch 另種包法
若 task3 需要 task2 資料
當 task2 掛了 3 就不會執行，進入 catch
```js
  try {
    let b = await task2()
    let c = await task3(b)
  } catch (error) {
  }
```


## try catch finally 範例碼
```js
  async function run3() {
    let result
    try {
      result = true
      // return result
    } catch (e) {
      result = false
      // return result
    } finally {
      console.log('finally')
    }
    return result  // 亦可將 return 寫於此
  }
```

## try catch 的 finally
finally 不管正確、錯誤都會執行
finally 用途 確保 程式可以 close
//! 不應該於 finally 放 return
//* finally 的 return 會覆蓋 try 的 return

try catch 越精簡越好、效能較 if 較差
//? 因為 run time 才會做 compile
```js
  async function run() {
    let result = true
    try {
      return result
    } catch (e) {
      console.log(e)
      result = false
      return result
    } finally {
      console.log('return勿放此 此必會執行')
    }
  }
```

## 較少用的補充
# Generator [基本用不到]
* promise-all 
> 類似於 jQuery.when()
[避免使用，因為可能一次發過多AJAX]
一次送出去，等到所有回來才會做 then()
無法控制順序，控制性較少，小專案才會用(方便)
```js
  Promise.all([task1(), task2()])
    .then((result) => {
      console.log(result)
    }).catch((err) => {
      console.log(err)
    })
```
* promise-race (非常少用)
只看首個回傳，通常會看整個過程